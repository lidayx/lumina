# 应用和书签搜索优化方案

## 📱 应用搜索优化

### 当前实现分析

**macOS:**
- ❌ 遍历 `/Applications` 和 `~/Applications` 目录（全量扫描）
- ✅ 使用 `mdls` 获取显示名称（支持本地化）
- ✅ 读取 `Info.plist` 获取图标

**Windows:**
- ❌ 递归扫描 `C:\Program Files` 等目录（深度 3 级，性能差）
- ❌ 只扫描 `.exe`，可能遗漏 UWP 应用和 Start Menu 快捷方式

**Linux:**
- ✅ 读取 `.desktop` 文件（符合规范）
- ⚠️ 缺少图标支持

### 优化方案

#### 1. macOS - 使用 Spotlight 索引（推荐 ⭐）

**优势:**
- 利用系统索引，速度快（毫秒级）
- 自动排除隐藏/系统应用
- 支持应用名称本地化

**实现:**
```typescript
// 使用 mdfind 查询 Spotlight 索引
private async indexMacAppsWithSpotlight(): Promise<Map<string, AppInfo>> {
  const { execSync } = require('child_process');
  const appsMap = new Map<string, AppInfo>();
  
  try {
    // 查询所有应用包（kMDItemContentType == com.apple.application-bundle）
    const command = 'mdfind "kMDItemContentType==com.apple.application-bundle && kMDItemKind==Application"';
    const output = execSync(command, { encoding: 'utf-8', maxBuffer: 10 * 1024 * 1024 });
    const appPaths = output.trim().split('\n').filter(p => p);
    
    for (const appPath of appPaths) {
      // 只处理标准应用目录中的应用（排除系统应用）
      if (appPath.startsWith('/Applications/') || appPath.startsWith(process.env.HOME + '/Applications/')) {
        await this.addMacApp(appPath, path.basename(appPath, '.app'), appsMap);
      }
    }
  } catch (error) {
    console.error('Spotlight 查询失败，回退到目录扫描:', error);
    // 回退到现有的目录扫描方案
    await this.indexMacApps(appsMap);
  }
  
  return appsMap;
}
```

**性能提升:** 从秒级降低到毫秒级，特别是应用数量多时优势明显

---

#### 2. Windows - 使用 Start Menu + PowerShell（推荐 ⭐）

**优势:**
- Start Menu 只包含用户可见的应用
- PowerShell 查询速度快
- 支持 UWP 应用和传统桌面应用

**实现:**
```typescript
private async indexWindowsAppsFromStartMenu(): Promise<Map<string, AppInfo>> {
  const { execSync } = require('child_process');
  const appsMap = new Map<string, AppInfo>();
  
  const startMenuPaths = [
    path.join(process.env.APPDATA || '', 'Microsoft', 'Windows', 'Start Menu', 'Programs'),
    path.join(process.env.PROGRAMDATA || '', 'Microsoft', 'Windows', 'Start Menu', 'Programs'),
  ];
  
  for (const startMenuPath of startMenuPaths) {
    if (!fs.existsSync(startMenuPath)) continue;
    
    // 使用 PowerShell 递归查找 .lnk 文件
    const psCommand = `
      Get-ChildItem -Path "${startMenuPath}" -Filter *.lnk -Recurse -ErrorAction SilentlyContinue | 
      ForEach-Object { 
        $shell = New-Object -ComObject WScript.Shell
        $shortcut = $shell.CreateShortcut($_.FullName)
        [PSCustomObject]@{
          Name = $_.BaseName
          Path = $shortcut.TargetPath
          Icon = $shortcut.IconLocation
        }
      } | ConvertTo-Json -Compress
    `;
    
    try {
      const output = execSync(
        `powershell -NoProfile -ExecutionPolicy Bypass -Command "${psCommand}"`,
        { encoding: 'utf-8', maxBuffer: 10 * 1024 * 1024 }
      );
      
      const shortcuts = JSON.parse(output);
      for (const shortcut of Array.isArray(shortcuts) ? shortcuts : [shortcuts]) {
        if (shortcut.Path && fs.existsSync(shortcut.Path)) {
          appsMap.set(`win-${shortcut.Name}`, {
            id: `win-${shortcut.Name}`,
            name: shortcut.Name,
            path: shortcut.Path,
            icon: shortcut.Icon,
            launchCount: 0,
            lastUsed: new Date(),
          });
        }
      }
    } catch (error) {
      console.error(`Start Menu 扫描失败 ${startMenuPath}:`, error);
    }
  }
  
  return appsMap;
}
```

**性能提升:** 从深度递归扫描（可能耗时数分钟）降低到秒级

---

#### 3. Linux - 增强 .desktop 解析（小幅优化）

**改进点:**
- 解析 `Icon` 字段，支持图标路径
- 处理 `Exec` 参数（%f, %u 等）
- 读取 `Categories` 用于分类

**实现:**
```typescript
private async addLinuxApp(desktopPath: string, targetMap?: Map<string, AppInfo>): Promise<void> {
  try {
    const content = fs.readFileSync(desktopPath, 'utf-8');
    
    const parseDesktopFile = (content: string) => {
      const lines = content.split('\n');
      const result: Record<string, string> = {};
      
      for (const line of lines) {
        if (line.includes('=') && !line.startsWith('#')) {
          const [key, ...valueParts] = line.split('=');
          result[key.trim()] = valueParts.join('=').trim();
        }
      }
      
      return result;
    };
    
    const desktop = parseDesktopFile(content);
    
    // 跳过 NoDisplay=true 或 Hidden=true 的应用
    if (desktop.NoDisplay === 'true' || desktop.Hidden === 'true') {
      return;
    }
    
    if (desktop.Name && desktop.Exec) {
      const appInfo: AppInfo = {
        id: `linux-${desktop.Name}`,
        name: desktop.Name,
        path: desktopPath,
        icon: desktop.Icon || undefined,
        launchCount: 0,
        lastUsed: new Date(),
      };
      
      const appsMap = targetMap || this.apps;
      appsMap.set(appInfo.id, appInfo);
    }
  } catch (error) {
    console.error(`⚠️ [应用服务] 添加应用失败 ${desktopPath}:`, error);
  }
}
```

---

## 📚 书签搜索优化

### 当前实现分析

**优点:**
- ✅ 支持 Chrome/Edge/Opera（JSON 格式）
- ✅ 从数据库缓存加载（启动快）
- ✅ 支持多浏览器路径检测

**缺点:**
- ❌ 仅支持 Firefox HTML 格式（已过时，现代 Firefox 使用 SQLite）
- ❌ Safari plist 未实现
- ❌ 无增量更新（定时全量扫描）
- ❌ 未监控书签文件变化（需要手动刷新）

### 优化方案

#### 1. Firefox - 使用 SQLite（推荐 ⭐）

现代 Firefox 使用 `places.sqlite` 数据库存储书签，性能更好：

```typescript
private async readFirefoxBookmarksFromSQLite(profilePath: string): Promise<Bookmark[]> {
  const sqlite3 = require('sqlite3');
  const dbPath = path.join(profilePath, 'places.sqlite');
  
  if (!fs.existsSync(dbPath)) return [];
  
  return new Promise((resolve, reject) => {
    const db = new sqlite3.Database(dbPath, sqlite3.OPEN_READONLY, (err) => {
      if (err) {
        reject(err);
        return;
      }
      
      const query = `
        SELECT 
          b.id,
          b.title as name,
          p.url,
          b.dateAdded / 1000000 as dateAdded,
          h.last_visit_date / 1000 as dateLastUsed
        FROM moz_bookmarks b
        JOIN moz_places p ON b.fk = p.id
        LEFT JOIN moz_historyvisits h ON p.id = h.place_id
        WHERE b.type = 1 AND p.url IS NOT NULL
        ORDER BY b.dateAdded DESC
      `;
      
      db.all(query, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows.map(row => ({
            id: `ff-${row.id}`,
            name: row.name || row.url,
            url: row.url,
            dateAdded: row.dateAdded ? Math.floor(row.dateAdded / 1000) : undefined,
            dateLastUsed: row.dateLastUsed ? Math.floor(row.dateLastUsed) : undefined,
          })));
        }
        db.close();
      });
    });
  });
}
```

**性能提升:** 从 HTML 解析（慢且过时）到 SQLite 查询（快速准确）

---

#### 2. Safari - 实现 plist 解析（推荐 ⭐）

使用 Node.js 的 `plist` 库或 macOS 的 `plutil` 命令：

```typescript
private async readSafariBookmarks(bookmarkPath: string): Promise<Bookmark[]> {
  const { execSync } = require('child_process');
  
  try {
    // 使用 plutil 转换为 JSON
    const command = `plutil -convert json -o - "${bookmarkPath}"`;
    const output = execSync(command, { encoding: 'utf-8' });
    const data = JSON.parse(output);
    
    const bookmarks: Bookmark[] = [];
    
    const traverse = (node: any) => {
      if (node.WebBookmarkType === 'WebBookmarkTypeLeaf' && node.URLString) {
        bookmarks.push({
          id: `safari-${node.WebBookmarkUUID || Date.now()}-${bookmarks.length}`,
          name: node.URIDictionary?.title?.string || node.URLString,
          url: node.URLString,
        });
      }
      
      if (node.Children) {
        node.Children.forEach((child: any) => traverse(child));
      }
    };
    
    if (data.Children) {
      data.Children.forEach((child: any) => traverse(child));
    }
    
    return bookmarks;
  } catch (error) {
    console.error('读取 Safari 书签失败:', error);
    return [];
  }
}
```

---

#### 3. 文件监控 - 增量更新（推荐 ⭐）

监控单个书签文件变化，避免定时全量扫描：

```typescript
private bookmarkWatcher: fs.FSWatcher | null = null;

private startBookmarkWatcher(bookmarkPath: string): void {
  if (this.bookmarkWatcher) {
    this.bookmarkWatcher.close();
  }
  
  this.bookmarkWatcher = fs.watch(bookmarkPath, (eventType) => {
    if (eventType === 'change') {
      console.log('📚 [书签服务] 检测到书签文件变化，重新加载...');
      // 防抖：延迟 1 秒后重新加载（避免频繁触发）
      setTimeout(async () => {
        await this.scanBookmarks(bookmarkPath);
      }, 1000);
    }
  });
  
  this.bookmarkWatcher.on('error', (error) => {
    console.error('书签文件监控错误:', error);
  });
}

// 在 loadBookmarks 中调用
public async loadBookmarks(): Promise<void> {
  // ... 现有代码 ...
  
  if (this.bookmarkPath && fs.existsSync(this.bookmarkPath)) {
    // 启动文件监控
    this.startBookmarkWatcher(this.bookmarkPath);
  }
}
```

**优势:**
- 实时更新书签（无需等待定时任务）
- 只监控单个文件（性能开销小）
- 减少不必要的全量扫描

---

## 📊 优化收益总结

| 优化项 | 当前方案 | 优化方案 | 性能提升 | 实施难度 |
|--------|---------|---------|---------|---------|
| macOS 应用搜索 | 目录遍历 | Spotlight 索引 | ⚡⚡⚡ 秒级→毫秒级 | ⭐⭐ 中等 |
| Windows 应用搜索 | 递归扫描 | Start Menu + PowerShell | ⚡⚡⚡ 分钟级→秒级 | ⭐⭐⭐ 较难 |
| Linux 应用搜索 | .desktop 解析 | 增强解析（图标、分类） | ⚡ 小幅提升 | ⭐ 简单 |
| Firefox 书签 | HTML 解析 | SQLite 查询 | ⚡⚡ 显著提升 | ⭐⭐ 中等 |
| Safari 书签 | 未实现 | plist 解析 | ⚡⚡ 新功能 | ⭐⭐ 中等 |
| 书签增量更新 | 定时全量扫描 | 文件监控 | ⚡⚡ 实时更新 | ⭐ 简单 |

---

## 🎯 推荐实施优先级

1. **高优先级（快速见效）:**
   - ✅ 书签文件监控（简单，收益高）
   - ✅ macOS Spotlight 应用搜索（性能提升显著）

2. **中优先级（功能完善）:**
   - ✅ Firefox SQLite 书签支持
   - ✅ Safari plist 书签支持

3. **低优先级（可选）:**
   - ⚠️ Windows Start Menu 优化（需 PowerShell，复杂度高）
   - ⚠️ Linux 图标支持（用户体验提升有限）

---

## 💡 实施建议

1. **保持向后兼容:** 新方案失败时回退到现有方案
2. **渐进式优化:** 先实施高优先级项，观察效果后再继续
3. **性能监控:** 记录索引耗时，对比优化前后效果
4. **用户配置:** 可考虑让用户选择使用新方案或旧方案（设置项）

